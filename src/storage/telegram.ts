import { z } from "zod";
import { StorageProvider, StoreFileInput, StorageResult } from "./types.js";

/**
 * Zod schema for Telegram storage configuration.
 */
export const TelegramStorageConfigSchema = z.object({
  /** Telegram Bot API token (from @BotFather). */
  botToken: z.string().min(1),

  /** Target chat ID (can be user, group, or channel). */
  chatId: z.string().min(1),

  /** Optional message caption template. */
  captionTemplate: z.string().optional(),

  /** Whether to send as document (preserves quality) vs photo (compressed). */
  sendAsDocument: z.boolean().optional(),
});

export type TelegramStorageConfig = z.infer<typeof TelegramStorageConfigSchema>;

/**
 * Storage provider that sends files to Telegram chats/channels.
 *
 * Files are uploaded via the Telegram Bot API and sent to the specified chat.
 * The bot must have permission to send messages to the target chat.
 *
 * @example
 * ```typescript
 * const storage = new TelegramStorageProvider({
 *   botToken: "123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11",
 *   chatId: "-1001234567890",
 * });
 *
 * const result = await storage.store({
 *   content: pngBuffer,
 *   filename: "diagram.png",
 *   mimeType: "image/png",
 * });
 * ```
 */
export class TelegramStorageProvider implements StorageProvider {
  readonly type = "telegram";
  private readonly config: TelegramStorageConfig;
  private readonly baseUrl: string;

  constructor(config: TelegramStorageConfig) {
    this.config = TelegramStorageConfigSchema.parse(config);
    this.baseUrl = `https://api.telegram.org/bot${this.config.botToken}`;
  }

  async store(input: StoreFileInput): Promise<StorageResult> {
    const content = Buffer.isBuffer(input.content)
      ? input.content
      : Buffer.from(input.content, "base64");

    const caption =
      this.config.captionTemplate?.replace("{filename}", input.filename) ??
      `${input.filename} - Generated by Napkin AI`;

    // Use sendDocument for SVG/PPT, sendPhoto for images
    const isImage = input.mimeType?.startsWith("image/") && input.mimeType !== "image/svg+xml";
    const endpoint = this.config.sendAsDocument || !isImage ? "sendDocument" : "sendPhoto";
    const fieldName = endpoint === "sendDocument" ? "document" : "photo";

    // Create form data
    const formData = new globalThis.FormData();
    formData.append("chat_id", this.config.chatId);
    formData.append("caption", caption);
    formData.append(
      fieldName,
      new globalThis.Blob([content], { type: input.mimeType }),
      input.filename
    );

    const response = await globalThis.fetch(`${this.baseUrl}/${endpoint}`, {
      method: "POST",
      body: formData,
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to send to Telegram: ${response.status} ${error}`);
    }

    const result = (await response.json()) as {
      ok: boolean;
      result: {
        message_id: number;
        document?: { file_id: string };
        photo?: Array<{ file_id: string }>;
      };
    };

    const messageId = result.result.message_id;
    const fileId =
      result.result.document?.file_id ?? result.result.photo?.[0]?.file_id ?? "unknown";

    return {
      location: `telegram://${this.config.chatId}/${messageId}`,
      metadata: {
        chatId: this.config.chatId,
        messageId,
        fileId,
        filename: input.filename,
      },
    };
  }

  isConfigured(): boolean {
    return Boolean(this.config.botToken && this.config.chatId);
  }
}

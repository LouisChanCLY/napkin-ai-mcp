import { z } from "zod";
import { StorageProvider, StoreFileInput, StorageResult } from "./types.js";

/**
 * Zod schema for Discord storage configuration.
 */
export const DiscordStorageConfigSchema = z.object({
  /** Discord webhook URL. */
  webhookUrl: z.string().url(),

  /** Optional username for the webhook message. */
  username: z.string().optional(),

  /** Optional avatar URL for the webhook message. */
  avatarUrl: z.string().url().optional(),

  /** Optional message content template. */
  messageTemplate: z.string().optional(),
});

export type DiscordStorageConfig = z.infer<typeof DiscordStorageConfigSchema>;

/**
 * Storage provider that sends files to Discord via webhooks.
 *
 * Files are uploaded via Discord webhook and posted to the channel.
 * No bot setup required - just create a webhook in channel settings.
 *
 * @example
 * ```typescript
 * const storage = new DiscordStorageProvider({
 *   webhookUrl: "https://discord.com/api/webhooks/123/abc...",
 *   username: "Napkin AI",
 * });
 *
 * const result = await storage.store({
 *   content: pngBuffer,
 *   filename: "diagram.png",
 *   mimeType: "image/png",
 * });
 * ```
 */
export class DiscordStorageProvider implements StorageProvider {
  readonly type = "discord";
  private readonly config: DiscordStorageConfig;

  constructor(config: DiscordStorageConfig) {
    this.config = DiscordStorageConfigSchema.parse(config);
  }

  async store(input: StoreFileInput): Promise<StorageResult> {
    const content = Buffer.isBuffer(input.content)
      ? input.content
      : Buffer.from(input.content, "base64");

    const message =
      this.config.messageTemplate?.replace("{filename}", input.filename) ??
      `**${input.filename}** - Generated by Napkin AI`;

    // Create form data for multipart upload
    const formData = new globalThis.FormData();

    // Add payload JSON
    const payload: Record<string, unknown> = {
      content: message,
    };
    if (this.config.username) {
      payload.username = this.config.username;
    }
    if (this.config.avatarUrl) {
      payload.avatar_url = this.config.avatarUrl;
    }
    formData.append("payload_json", JSON.stringify(payload));

    // Add file
    formData.append(
      "files[0]",
      new globalThis.Blob([content], { type: input.mimeType }),
      input.filename
    );

    const response = await globalThis.fetch(this.config.webhookUrl, {
      method: "POST",
      body: formData,
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to send to Discord: ${response.status} ${error}`);
    }

    const result = (await response.json()) as {
      id: string;
      channel_id: string;
      attachments?: Array<{ id: string; url: string }>;
    };

    const attachmentUrl = result.attachments?.[0]?.url;

    return {
      location: `discord://${result.channel_id}/${result.id}`,
      publicUrl: attachmentUrl,
      metadata: {
        channelId: result.channel_id,
        messageId: result.id,
        attachmentUrl,
        filename: input.filename,
      },
    };
  }

  isConfigured(): boolean {
    return Boolean(this.config.webhookUrl);
  }
}
